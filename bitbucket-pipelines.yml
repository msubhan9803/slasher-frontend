definitions:
  caches:
    node: node_modules
  services:
    docker:
      # Below, increase the default available docker memory to speed up docker apps.
      # Note: Whatever amount is allocated here will be deducted from the amount of memory allocated
      # to the main process. 4096 MB is the total available amount for a default "1x" pipeline instance.
      memory: 2048
  steps:
    - step: &lint-test-build
        # If our test runs for more than the number of minutes specified below, something is
        # probably wrong. We'll limit test run time so we don't waste CI build minutes.
        max-time: 30
        name: Lint, test, and build
        image: node:16.13.1
        services:
          - docker
        caches:
          - node
          - docker
        script:
          # Install NPM dependencies
          - npm ci
          # Run linter
          - npm run lint
          # Start docker mongo
          - >
            DOCKER_MONGO_CONTAINER_ID=$(
            docker run --detach -p 27017:27017
            --env MONGO_INITDB_ROOT_USERNAME=root --env MONGO_INITDB_ROOT_PASSWORD=rootpassword
            $(docker build -q ./docker/mongo)
            )
          # Start redis mongo
          - >
            DOCKER_REDIS_CONTAINER_ID=$(
            docker run --detach -p 6389:6379
            $(docker build -q ./docker/redis)
            )
          # Copy template env file to .env.test (to support testing)
          - cp .env.test.template .env.test
          # Run tests
          - npm run test
          - npm run test:e2e-core
          - npm run test:e2e-gateway
          # Stop docker mongo (kill for speed, since this is CI and clean shutdown doesn't matter)
          - docker container kill $DOCKER_MONGO_CONTAINER_ID
          # Stop docker redis (kill for speed, since this is CI and clean shutdown doesn't matter)
          - docker container kill $DOCKER_REDIS_CONTAINER_ID
          # Run build (to ensure that build succeeds)
          - npm run build

    - step: &set-environment
        name: 'Set Environment'
        script:
          - echo $BITBUCKET_BRANCH | cut -c 8- > environment.txt
          - cat environment.txt
        artifacts:
          - environment.txt

    - step: &terraform-deploy
        caches:
          - docker
        name: 'terraform plan and apply'
        image: hashicorp/terraform:1.4.0
        script:
          - echo "Deploying infra"
          - export ENVIRONMENT=$(cat ./environment.txt)
          - cd terraform
          - export AWS_DEFAULT_REGION="us-east-1"
          - terraform init
          - terraform workspace select "$ENVIRONMENT" || terraform workspace new "$ENVIRONMENT"
          - terraform version
          - terraform validate
          - terraform plan --var-file=env.tfvars/"$ENVIRONMENT".tfvars
          - terraform apply --var-file=env.tfvars/"$ENVIRONMENT".tfvars -auto-approve
        services:
          - docker

    - step: &build-and-push-web-new-docker-image-to-ecr
        caches:
          - docker
        name: 'Build and push slasher-web new Docker image to ECR'
        image: atlassian/pipelines-awscli
        script:
          - export ENVIRONMENT=$(cat ./environment.txt)
          - docker build --tag slasher-web-new-"$ENVIRONMENT" --file app.Dockerfile .
          - pipe: atlassian/aws-ecr-push-image:1.4.2
            variables:
              IMAGE_NAME: "slasher-web-new-$ENVIRONMENT"
              TAGS: "${BITBUCKET_BUILD_NUMBER}"
              DEBUG: "true"
        services:
          - docker

    - step: &build-and-push-server-cron-docker-image-to-ecr
        name: 'Build and push slasher-cron Docker image to ECR'
        caches:
          - docker
        image: atlassian/pipelines-awscli
        script:
          - export ENVIRONMENT=$(cat ./environment.txt)
          - docker build --tag slasher-cron-"$ENVIRONMENT" --file cron.Dockerfile .
          - pipe: atlassian/aws-ecr-push-image:1.4.2
            variables:
              IMAGE_NAME: "slasher-cron-$ENVIRONMENT"
              TAGS: "${BITBUCKET_BUILD_NUMBER}"
              DEBUG: "true"
        services:
          - docker

    - step: &ECS-deploy-web-new
        name: 'ECS deployment Slasher-Web new'
        caches:
          - docker
        image: atlassian/pipelines-awscli
        script:
          - export ENVIRONMENT=$(cat ./environment.txt)
          - AWS_REGION="us-east-1"
          - ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" | tr -d '"')
          - IMAGE_URL="$ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/slasher-web-new-$ENVIRONMENT:${BITBUCKET_BUILD_NUMBER}"
          - aws ecs describe-task-definition --task-definition slasher-web-new-task-defination-"$ENVIRONMENT" --query taskDefinition --region us-east-1 | jq '.containerDefinitions[0].image = "'$IMAGE_URL'" | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)' > task-definition.json
          - cat task-definition.json
          - pipe: atlassian/aws-ecs-deploy:1.7.0
            variables:
              AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
              AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
              AWS_DEFAULT_REGION: 'us-east-1'
              CLUSTER_NAME: 'ecs-fargate-cluster-$ENVIRONMENT'
              SERVICE_NAME: 'slasher-web-new-service-$ENVIRONMENT'
              TASK_DEFINITION: 'task-definition.json'
              FORCE_NEW_DEPLOYMENT: 'true'
              WAIT: 'true'
        services:
          - docker

    - step: &ECS-deploy-cron
        name: 'ECS deployment Slasher-Cron'
        caches:
          - docker
        image: atlassian/pipelines-awscli
        script:
          - export ENVIRONMENT=$(cat ./environment.txt)
          - AWS_REGION="us-east-1"
          - ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" | tr -d '"')
          - IMAGE_URL="$ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/slasher-cron-$ENVIRONMENT:${BITBUCKET_BUILD_NUMBER}"
          - aws ecs describe-task-definition --task-definition slasher-cron-task-defination-$ENVIRONMENT --query taskDefinition --region us-east-1 | jq '.containerDefinitions[0].image = "'$IMAGE_URL'" | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)' > task-definition.json
          - pipe: atlassian/aws-ecs-deploy:1.7.0
            variables:
              AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
              AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
              AWS_DEFAULT_REGION: 'us-east-1'
              CLUSTER_NAME: 'ecs-fargate-cluster-$ENVIRONMENT'
              SERVICE_NAME: 'slasher-cron-service-$ENVIRONMENT'
              TASK_DEFINITION: 'task-definition.json'
              FORCE_NEW_DEPLOYMENT: 'true'
              WAIT: 'true'
        services:
          - docker

pipelines:
  branches:
    main:
      - step: *lint-test-build
    deploy/staging:
    - step: *set-environment
    - step: *terraform-deploy
    - step: *build-and-push-web-new-docker-image-to-ecr
    - step: *build-and-push-server-cron-docker-image-to-ecr
    - step: *ECS-deploy-web-new
    - step: *ECS-deploy-cron
    deploy/prod:
    - step: *set-environment
    - step: *terraform-deploy
    - step: *build-and-push-web-new-docker-image-to-ecr
    - step: *build-and-push-server-cron-docker-image-to-ecr
    - step: *ECS-deploy-web-new
    - step: *ECS-deploy-cron
  pull-requests:
    # Run for any branch that has an open pull request
    '**':
      - step: *lint-test-build
